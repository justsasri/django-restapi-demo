(self.webpackChunkdjango_restapi_demo=self.webpackChunkdjango_restapi_demo||[]).push([["shared"],{"./node_modules/alpinejs/dist/module.esm.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": function() { return /* binding */ module_default; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction _ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? _ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : _ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\n\nfunction _scheduler(callback) {\n  queueJob(callback);\n}\n\nfunction queueJob(job) {\n  if (!queue.includes(job)) queue.push(job);\n  queueFlush();\n}\n\nfunction dequeueJob(job) {\n  var index = queue.indexOf(job);\n  if (index !== -1) queue.splice(index, 1);\n}\n\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\n\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n\n  queue.length = 0;\n  flushing = false;\n} // packages/alpinejs/src/reactivity.js\n\n\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\n\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\n\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n\n  effect = callback => engine.effect(callback, {\n    scheduler: task => {\n      if (shouldSchedule) {\n        _scheduler(task);\n      } else {\n        task();\n      }\n    }\n  });\n\n  raw = engine.raw;\n}\n\nfunction overrideEffect(override) {\n  effect = override;\n}\n\nfunction elementBoundEffect(el) {\n  var cleanup2 = () => {};\n\n  var wrappedEffect = callback => {\n    var effectReference = effect(callback);\n\n    if (!el._x_effects) {\n      el._x_effects = new Set();\n\n      el._x_runEffects = () => {\n        el._x_effects.forEach(i => i());\n      };\n    }\n\n    el._x_effects.add(effectReference);\n\n    cleanup2 = () => {\n      if (effectReference === void 0) return;\n\n      el._x_effects.delete(effectReference);\n\n      release(effectReference);\n    };\n\n    return effectReference;\n  };\n\n  return [wrappedEffect, () => {\n    cleanup2();\n  }];\n} // packages/alpinejs/src/mutation.js\n\n\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\n\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\n\nfunction onElRemoved(el, callback) {\n  if (typeof callback === "function") {\n    if (!el._x_cleanups) el._x_cleanups = [];\n\n    el._x_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\n\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\n\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups) el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name]) el._x_attributeCleanups[name] = [];\n\n  el._x_attributeCleanups[name].push(callback);\n}\n\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups) return;\n  Object.entries(el._x_attributeCleanups).forEach(_ref => {\n    var [name, value] = _ref;\n\n    if (names === void 0 || names.includes(name)) {\n      value.forEach(i => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\n\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\n\nfunction startObservingMutations() {\n  observer.observe(document, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true\n  });\n  currentlyObserving = true;\n}\n\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\n\nvar recordQueue = [];\nvar willProcessRecordQueue = false;\n\nfunction flushObserver() {\n  recordQueue = recordQueue.concat(observer.takeRecords());\n\n  if (recordQueue.length && !willProcessRecordQueue) {\n    willProcessRecordQueue = true;\n    queueMicrotask(() => {\n      processRecordQueue();\n      willProcessRecordQueue = false;\n    });\n  }\n}\n\nfunction processRecordQueue() {\n  onMutate(recordQueue);\n  recordQueue.length = 0;\n}\n\nfunction mutateDom(callback) {\n  if (!currentlyObserving) return callback();\n  stopObservingMutations();\n  var result = callback();\n  startObservingMutations();\n  return result;\n}\n\nvar isCollecting = false;\nvar deferredMutations = [];\n\nfunction deferMutations() {\n  isCollecting = true;\n}\n\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\n\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n\n  var addedNodes = [];\n  var removedNodes = [];\n  var addedAttributes = new Map();\n  var removedAttributes = new Map();\n\n  for (var i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver) continue;\n\n    if (mutations[i].type === "childList") {\n      mutations[i].addedNodes.forEach(node => node.nodeType === 1 && addedNodes.push(node));\n      mutations[i].removedNodes.forEach(node => node.nodeType === 1 && removedNodes.push(node));\n    }\n\n    if (mutations[i].type === "attributes") {\n      (function () {\n        var el = mutations[i].target;\n        var name = mutations[i].attributeName;\n        var oldValue = mutations[i].oldValue;\n\n        var add2 = () => {\n          if (!addedAttributes.has(el)) addedAttributes.set(el, []);\n          addedAttributes.get(el).push({\n            name,\n            value: el.getAttribute(name)\n          });\n        };\n\n        var remove = () => {\n          if (!removedAttributes.has(el)) removedAttributes.set(el, []);\n          removedAttributes.get(el).push(name);\n        };\n\n        if (el.hasAttribute(name) && oldValue === null) {\n          add2();\n        } else if (el.hasAttribute(name)) {\n          remove();\n          add2();\n        } else {\n          remove();\n        }\n      })();\n    }\n  }\n\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach(i => i(el, attrs));\n  });\n\n  var _loop = function _loop(node) {\n    if (addedNodes.includes(node)) return "continue";\n    onElRemoveds.forEach(i => i(node));\n\n    if (node._x_cleanups) {\n      while (node._x_cleanups.length) {\n        node._x_cleanups.pop()();\n      }\n    }\n  };\n\n  for (var node of removedNodes) {\n    var _ret = _loop(node);\n\n    if (_ret === "continue") continue;\n  }\n\n  addedNodes.forEach(node => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n\n  var _loop2 = function _loop2(_node) {\n    if (removedNodes.includes(_node)) return "continue";\n    if (!_node.isConnected) return "continue";\n    delete _node._x_ignoreSelf;\n    delete _node._x_ignore;\n    onElAddeds.forEach(i => i(_node));\n    _node._x_ignore = true;\n    _node._x_ignoreSelf = true;\n  };\n\n  for (var _node of addedNodes) {\n    var _ret2 = _loop2(_node);\n\n    if (_ret2 === "continue") continue;\n  }\n\n  addedNodes.forEach(node => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n} // packages/alpinejs/src/scope.js\n\n\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\n\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter(i => i !== data2);\n  };\n}\n\nfunction refreshScope(element, scope2) {\n  var existingScope = element._x_dataStack[0];\n  Object.entries(scope2).forEach(_ref2 => {\n    var [key, value] = _ref2;\n    existingScope[key] = value;\n  });\n}\n\nfunction closestDataStack(node) {\n  if (node._x_dataStack) return node._x_dataStack;\n\n  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n\n  if (!node.parentNode) {\n    return [];\n  }\n\n  return closestDataStack(node.parentNode);\n}\n\nfunction mergeProxies(objects) {\n  var thisProxy = new Proxy({}, {\n    ownKeys: () => {\n      return Array.from(new Set(objects.flatMap(i => Object.keys(i))));\n    },\n    has: (target, name) => {\n      return objects.some(obj => obj.hasOwnProperty(name));\n    },\n    get: (target, name) => {\n      return (objects.find(obj => {\n        if (obj.hasOwnProperty(name)) {\n          var descriptor = Object.getOwnPropertyDescriptor(obj, name);\n\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\n            return true;\n          }\n\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n            var getter = descriptor.get;\n            var setter = descriptor.set;\n            var property = descriptor;\n            getter = getter && getter.bind(thisProxy);\n            setter = setter && setter.bind(thisProxy);\n            if (getter) getter._x_alreadyBound = true;\n            if (setter) setter._x_alreadyBound = true;\n            Object.defineProperty(obj, name, _objectSpread(_objectSpread({}, property), {}, {\n              get: getter,\n              set: setter\n            }));\n          }\n\n          return true;\n        }\n\n        return false;\n      }) || {})[name];\n    },\n    set: (target, name, value) => {\n      var closestObjectWithKey = objects.find(obj => obj.hasOwnProperty(name));\n\n      if (closestObjectWithKey) {\n        closestObjectWithKey[name] = value;\n      } else {\n        objects[objects.length - 1][name] = value;\n      }\n\n      return true;\n    }\n  });\n  return thisProxy;\n} // packages/alpinejs/src/interceptor.js\n\n\nfunction initInterceptors(data2) {\n  var isObject2 = val => typeof val === "object" && !Array.isArray(val) && val !== null;\n\n  var recurse = function recurse(obj) {\n    var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(_ref3 => {\n      var [key, {\n        value,\n        enumerable\n      }] = _ref3;\n      if (enumerable === false || value === void 0) return;\n      var path = basePath === "" ? key : "".concat(basePath, ".").concat(key);\n\n      if (typeof value === "object" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject2(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n\n  return recurse(data2);\n}\n\nfunction interceptor(callback) {\n  var mutateObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  var obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), value => set(data2, path, value), path, key);\n    }\n\n  };\n  mutateObj(obj);\n  return initialValue => {\n    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {\n      var initialize = obj.initialize.bind(obj);\n\n      obj.initialize = (data2, path, key) => {\n        var innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n\n    return obj;\n  };\n}\n\nfunction get(obj, path) {\n  return path.split(".").reduce((carry, segment) => carry[segment], obj);\n}\n\nfunction set(obj, path, value) {\n  if (typeof path === "string") path = path.split(".");\n  if (path.length === 1) obj[path[0]] = value;else if (path.length === 0) throw error;else {\n    if (obj[path[0]]) return set(obj[path[0]], path.slice(1), value);else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n} // packages/alpinejs/src/magics.js\n\n\nvar magics = {};\n\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\n\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(_ref4 => {\n    var [name, callback] = _ref4;\n    Object.defineProperty(obj, "$".concat(name), {\n      get() {\n        var [utilities, cleanup2] = getElementBoundUtilities(el);\n        utilities = _objectSpread({\n          interceptor\n        }, utilities);\n        onElRemoved(el, cleanup2);\n        return callback(el, utilities);\n      },\n\n      enumerable: false\n    });\n  });\n  return obj;\n} // packages/alpinejs/src/utils/error.js\n\n\nfunction tryCatch(el, expression, callback) {\n  try {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\n\nfunction handleError(error2, el) {\n  var expression = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;\n  Object.assign(error2, {\n    el,\n    expression\n  });\n  console.warn("Alpine Expression Error: ".concat(error2.message, "\\n\\n").concat(expression ? \'Expression: "\' + expression + \'"\\n\\n\' : ""), el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n} // packages/alpinejs/src/evaluator.js\n\n\nvar shouldAutoEvaluateFunctions = true;\n\nfunction dontAutoEvaluateFunctions(callback) {\n  var cache = shouldAutoEvaluateFunctions;\n  shouldAutoEvaluateFunctions = false;\n  callback();\n  shouldAutoEvaluateFunctions = cache;\n}\n\nfunction evaluate(el, expression) {\n  var extras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var result;\n  evaluateLater(el, expression)(value => result = value, extras);\n  return result;\n}\n\nfunction evaluateLater() {\n  return theEvaluatorFunction(...arguments);\n}\n\nvar theEvaluatorFunction = normalEvaluator;\n\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\n\nfunction normalEvaluator(el, expression) {\n  var overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  var dataStack = [overriddenMagics, ...closestDataStack(el)];\n\n  if (typeof expression === "function") {\n    return generateEvaluatorFromFunction(dataStack, expression);\n  }\n\n  var evaluator = generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\n\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return function () {\n    var receiver = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    var {\n      scope: scope2 = {},\n      params = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\n\nvar evaluatorMemo = {};\n\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n\n  var AsyncFunction = Object.getPrototypeOf( /*#__PURE__*/_asyncToGenerator(function* () {})).constructor;\n  var rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? "(() => { ".concat(expression, " })()") : expression;\n\n  var safeAsyncFunction = () => {\n    try {\n      return new AsyncFunction(["__self", "scope"], "with (scope) { __self.result = ".concat(rightSideSafeExpression, " }; __self.finished = true; return __self.result;"));\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n\n  var func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\n\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  var func = generateFunctionFromString(expression, el);\n  return function () {\n    var receiver = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    var {\n      scope: scope2 = {},\n      params = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    func.result = void 0;\n    func.finished = false;\n    var completeScope = mergeProxies([scope2, ...dataStack]);\n\n    if (typeof func === "function") {\n      var promise = func(func, completeScope).catch(error2 => handleError(error2, el, expression));\n\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then(result => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch(error2 => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\n\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (shouldAutoEvaluateFunctions && typeof value === "function") {\n    var result = value.apply(scope2, params);\n\n    if (result instanceof Promise) {\n      result.then(i => runIfTypeOfFunction(receiver, i, scope2, params)).catch(error2 => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else {\n    receiver(value);\n  }\n} // packages/alpinejs/src/directives.js\n\n\nvar prefixAsString = "x-";\n\nfunction prefix() {\n  var subject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";\n  return prefixAsString + subject;\n}\n\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\n\nvar directiveHandlers = {};\n\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\n\nfunction directives(el, attributes, originalAttributeOverride) {\n  var transformedAttributeMap = {};\n  var directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map(directive2 => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\n\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter(attr => !outNonAlpineAttributes(attr));\n}\n\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = new Map();\nvar currentHandlerStackKey = Symbol();\n\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  var key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n\n  var flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length) {\n      directiveHandlerStacks.get(key).shift()();\n    }\n\n    directiveHandlerStacks.delete(key);\n  };\n\n  var stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n\n  callback(flushHandlers);\n  stopDeferring();\n}\n\nfunction getElementBoundUtilities(el) {\n  var cleanups = [];\n\n  var cleanup2 = callback => cleanups.push(callback);\n\n  var [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  var utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup: cleanup2,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n\n  var doCleanup = () => cleanups.forEach(i => i());\n\n  return [utilities, doCleanup];\n}\n\nfunction getDirectiveHandler(el, directive2) {\n  var noop = () => {};\n\n  var handler3 = directiveHandlers[directive2.type] || noop;\n  var [utilities, cleanup2] = getElementBoundUtilities(el);\n  onAttributeRemoved(el, directive2.original, cleanup2);\n\n  var fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf) return;\n    handler3.inline && handler3.inline(el, directive2, utilities);\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\n  };\n\n  fullHandler.runCleanups = cleanup2;\n  return fullHandler;\n}\n\nvar startingWith = (subject, replacement) => _ref6 => {\n  var {\n    name,\n    value\n  } = _ref6;\n  if (name.startsWith(subject)) name = name.replace(subject, replacement);\n  return {\n    name,\n    value\n  };\n};\n\nvar into = i => i;\n\nfunction toTransformedAttributes() {\n  var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  return _ref7 => {\n    var {\n      name,\n      value\n    } = _ref7;\n    var {\n      name: newName,\n      value: newValue\n    } = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, {\n      name,\n      value\n    });\n    if (newName !== name) callback(newName, name);\n    return {\n      name: newName,\n      value: newValue\n    };\n  };\n}\n\nvar attributeTransformers = [];\n\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\n\nfunction outNonAlpineAttributes(_ref8) {\n  var {\n    name\n  } = _ref8;\n  return alpineAttributeRegex().test(name);\n}\n\nvar alpineAttributeRegex = () => new RegExp("^".concat(prefixAsString, "([^:^.]+)\\\\b"));\n\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return _ref9 => {\n    var {\n      name,\n      value\n    } = _ref9;\n    var typeMatch = name.match(alpineAttributeRegex());\n    var valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\n    var modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    var original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map(i => i.replace(".", "")),\n      expression: value,\n      original\n    };\n  };\n}\n\nvar DEFAULT = "DEFAULT";\nvar directiveOrder = ["ignore", "ref", "data", "id", "bind", "init", "for", "mask", "model", "modelable", "transition", "show", "if", DEFAULT, "teleport", "element"];\n\nfunction byPriority(a, b) {\n  var typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  var typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n} // packages/alpinejs/src/utils/dispatch.js\n\n\nfunction dispatch(el, name) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  el.dispatchEvent(new CustomEvent(name, {\n    detail,\n    bubbles: true,\n    composed: true,\n    cancelable: true\n  }));\n} // packages/alpinejs/src/nextTick.js\n\n\nvar tickStack = [];\nvar isHolding = false;\n\nfunction nextTick() {\n  var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n  return new Promise(res => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\n\nfunction releaseNextTicks() {\n  isHolding = false;\n\n  while (tickStack.length) {\n    tickStack.shift()();\n  }\n}\n\nfunction holdNextTicks() {\n  isHolding = true;\n} // packages/alpinejs/src/utils/walk.js\n\n\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach(el2 => walk(el2, callback));\n    return;\n  }\n\n  var skip = false;\n  callback(el, () => skip = true);\n  if (skip) return;\n  var node = el.firstElementChild;\n\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n} // packages/alpinejs/src/utils/warn.js\n\n\nfunction warn(message) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  console.warn("Alpine Warning: ".concat(message), ...args);\n} // packages/alpinejs/src/lifecycle.js\n\n\nfunction start() {\n  if (!document.body) warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine\'s `<script>` tag?");\n  dispatch(document, "alpine:init");\n  dispatch(document, "alpine:initializing");\n  startObservingMutations();\n  onElAdded(el => initTree(el, walk));\n  onElRemoved(el => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach(handle => handle());\n  });\n\n  var outNestedComponents = el => !closestRoot(el.parentElement, true);\n\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach(el => {\n    initTree(el);\n  });\n  dispatch(document, "alpine:initialized");\n}\n\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\n\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map(fn => fn());\n}\n\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map(fn => fn());\n}\n\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\n\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\n\nfunction closestRoot(el) {\n  var includeInitSelectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return findClosest(el, element => {\n    var selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some(selector => element.matches(selector))) return true;\n  });\n}\n\nfunction findClosest(el, callback) {\n  if (!el) return;\n  if (callback(el)) return el;\n  if (el._x_teleportBack) el = el._x_teleportBack;\n  if (!el.parentElement) return;\n  return findClosest(el.parentElement, callback);\n}\n\nfunction isRoot(el) {\n  return rootSelectors().some(selector => el.matches(selector));\n}\n\nfunction initTree(el) {\n  var walker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : walk;\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      directives(el2, el2.attributes).forEach(handle => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\n\nfunction destroyTree(root) {\n  walk(root, el => cleanupAttributes(el));\n} // packages/alpinejs/src/utils/classes.js\n\n\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(" "));\n  } else if (typeof value === "object" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === "function") {\n    return setClasses(el, value());\n  }\n\n  return setClassesFromString(el, value);\n}\n\nfunction setClassesFromString(el, classString) {\n  var split = classString2 => classString2.split(" ").filter(Boolean);\n\n  var missingClasses = classString2 => classString2.split(" ").filter(i => !el.classList.contains(i)).filter(Boolean);\n\n  var addClassesAndReturnUndo = classes => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n\n  classString = classString === true ? classString = "" : classString || "";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\n\nfunction setClassesFromObject(el, classObject) {\n  var split = classString => classString.split(" ").filter(Boolean);\n\n  var forAdd = Object.entries(classObject).flatMap(_ref10 => {\n    var [classString, bool] = _ref10;\n    return bool ? split(classString) : false;\n  }).filter(Boolean);\n  var forRemove = Object.entries(classObject).flatMap(_ref11 => {\n    var [classString, bool] = _ref11;\n    return !bool ? split(classString) : false;\n  }).filter(Boolean);\n  var added = [];\n  var removed = [];\n  forRemove.forEach(i => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach(i => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach(i => el.classList.add(i));\n    added.forEach(i => el.classList.remove(i));\n  };\n} // packages/alpinejs/src/utils/styles.js\n\n\nfunction setStyles(el, value) {\n  if (typeof value === "object" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n\n  return setStylesFromString(el, value);\n}\n\nfunction setStylesFromObject(el, value) {\n  var previousStyles = {};\n  Object.entries(value).forEach(_ref12 => {\n    var [key, value2] = _ref12;\n    previousStyles[key] = el.style[key];\n\n    if (!key.startsWith("--")) {\n      key = kebabCase(key);\n    }\n\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute("style");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\n\nfunction setStylesFromString(el, value) {\n  var cache = el.getAttribute("style", value);\n  el.setAttribute("style", value);\n  return () => {\n    el.setAttribute("style", cache || "");\n  };\n}\n\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();\n} // packages/alpinejs/src/utils/once.js\n\n\nfunction once(callback) {\n  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n} // packages/alpinejs/src/directives/x-transition.js\n\n\ndirective("transition", (el, _ref13, _ref14) => {\n  var {\n    value,\n    modifiers,\n    expression\n  } = _ref13;\n  var {\n    evaluate: evaluate2\n  } = _ref14;\n  if (typeof expression === "function") expression = evaluate2(expression);\n\n  if (!expression) {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\n\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, "");\n  var directiveStorageMap = {\n    enter: classes => {\n      el._x_transition.enter.during = classes;\n    },\n    "enter-start": classes => {\n      el._x_transition.enter.start = classes;\n    },\n    "enter-end": classes => {\n      el._x_transition.enter.end = classes;\n    },\n    leave: classes => {\n      el._x_transition.leave.during = classes;\n    },\n    "leave-start": classes => {\n      el._x_transition.leave.start = classes;\n    },\n    "leave-end": classes => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\n\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  var doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;\n  var transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);\n  var transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);\n\n  if (modifiers.includes("in") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));\n  }\n\n  if (modifiers.includes("out") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));\n  }\n\n  var wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");\n  var wantsOpacity = wantsAll || modifiers.includes("opacity");\n  var wantsScale = wantsAll || modifiers.includes("scale");\n  var opacityValue = wantsOpacity ? 0 : 1;\n  var scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;\n  var delay = modifierValue(modifiers, "delay", 0);\n  var origin = modifierValue(modifiers, "origin", "center");\n  var property = "opacity, transform";\n  var durationIn = modifierValue(modifiers, "duration", 150) / 1e3;\n  var durationOut = modifierValue(modifiers, "duration", 75) / 1e3;\n  var easing = "cubic-bezier(0.4, 0.0, 0.2, 1)";\n\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: "".concat(durationIn, "s"),\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: "scale(".concat(scaleValue, ")")\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: "scale(1)"\n    };\n  }\n\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: "".concat(durationOut, "s"),\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: "scale(1)"\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: "scale(".concat(scaleValue, ")")\n    };\n  }\n}\n\nfunction registerTransitionObject(el, setFunction) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!el._x_transition) el._x_transition = {\n    enter: {\n      during: defaultValue,\n      start: defaultValue,\n      end: defaultValue\n    },\n    leave: {\n      during: defaultValue,\n      start: defaultValue,\n      end: defaultValue\n    },\n\n    in() {\n      var before = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n      var after = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n      transition(el, setFunction, {\n        during: this.enter.during,\n        start: this.enter.start,\n        end: this.enter.end\n      }, before, after);\n    },\n\n    out() {\n      var before = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n      var after = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n      transition(el, setFunction, {\n        during: this.leave.during,\n        start: this.leave.start,\n        end: this.leave.end\n      }, before, after);\n    }\n\n  };\n}\n\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function (el, value, show, hide) {\n  var clickAwayCompatibleShow = () => {\n    document.visibilityState === "visible" ? requestAnimationFrame(show) : setTimeout(show);\n  };\n\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n\n    return;\n  }\n\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {}, () => resolve(hide));\n\n    el._x_transitioning.beforeCancel(() => reject({\n      isFromCancelledTransition: true\n    }));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    var closest = closestHide(el);\n\n    if (closest) {\n      if (!closest._x_hideChildren) closest._x_hideChildren = [];\n\n      closest._x_hideChildren.push(el);\n    } else {\n      queueMicrotask(() => {\n        var hideAfterChildren = el2 => {\n          var carry = Promise.all([el2._x_hidePromise, ...(el2._x_hideChildren || []).map(hideAfterChildren)]).then(_ref15 => {\n            var [i] = _ref15;\n            return i();\n          });\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n\n        hideAfterChildren(el).catch(e => {\n          if (!e.isFromCancelledTransition) throw e;\n        });\n      });\n    }\n  });\n};\n\nfunction closestHide(el) {\n  var parent = el.parentNode;\n  if (!parent) return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\n\nfunction transition(el, setFunction) {\n  var {\n    during,\n    start: start2,\n    end\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var before = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};\n  var after = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : () => {};\n  if (el._x_transitioning) el._x_transitioning.cancel();\n\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n\n  var undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n\n    before,\n\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n\n    after,\n\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n\n  });\n}\n\nfunction performTransition(el, stages) {\n  var interrupted, reachedBefore, reachedEnd;\n  var finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore) stages.before();\n\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n\n      stages.after();\n      if (el.isConnected) stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n\n    cancel: once(function () {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted) return;\n    var duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;\n    var delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;\n    if (duration === 0) duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted) return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\n\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1) return fallback;\n  var rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue) return fallback;\n\n  if (key === "scale") {\n    if (isNaN(rawValue)) return fallback;\n  }\n\n  if (key === "duration") {\n    var match = rawValue.match(/([0-9]+)ms/);\n    if (match) return match[1];\n  }\n\n  if (key === "origin") {\n    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");\n    }\n  }\n\n  return rawValue;\n} // packages/alpinejs/src/clone.js\n\n\nvar isCloning = false;\n\nfunction skipDuringClone(callback) {\n  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  return function () {\n    return isCloning ? fallback(...arguments) : callback(...arguments);\n  };\n}\n\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack) newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n}\n\nfunction cloneTree(el) {\n  var hasRunThroughFirstEl = false;\n\n  var shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3)) return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n\n  initTree(el, shallowWalker);\n}\n\nfunction dontRegisterReactiveSideEffects(callback) {\n  var cache = effect;\n  overrideEffect((callback2, el) => {\n    var storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {};\n  });\n  callback();\n  overrideEffect(cache);\n} // packages/alpinejs/src/utils/bind.js\n\n\nfunction bind(el, name, value) {\n  var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  if (!el._x_bindings) el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes("camel") ? camelCase(name) : name;\n\n  switch (name) {\n    case "value":\n      bindInputValue(el, value);\n      break;\n\n    case "style":\n      bindStyles(el, value);\n      break;\n\n    case "class":\n      bindClasses(el, value);\n      break;\n\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\n\nfunction bindInputValue(el, value) {\n  if (el.type === "radio") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n\n    if (window.fromModel) {\n      el.checked = checkedAttrLooseCompare(el.value, value);\n    }\n  } else if (el.type === "checkbox") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === "SELECT") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value) return;\n    el.value = value;\n  }\n}\n\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses) el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\n\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles) el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\n\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name)) value = name;\n    setIfChanged(el, name, value);\n  }\n}\n\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\n\nfunction updateSelect(el, value) {\n  var arrayWrappedValue = [].concat(value).map(value2 => {\n    return value2 + "";\n  });\n  Array.from(el.options).forEach(option => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\n\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\n\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\n\nfunction isBooleanAttr(attrName) {\n  var booleanAttributes = ["disabled", "checked", "required", "readonly", "hidden", "open", "selected", "autofocus", "itemscope", "multiple", "novalidate", "allowfullscreen", "allowpaymentrequest", "formnovalidate", "autoplay", "controls", "loop", "muted", "playsinline", "default", "ismap", "reversed", "async", "defer", "nomodule"];\n  return booleanAttributes.includes(attrName);\n}\n\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);\n}\n\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0) return el._x_bindings[name];\n  var attr = el.getAttribute(name);\n  if (attr === null) return typeof fallback === "function" ? fallback() : fallback;\n\n  if (isBooleanAttr(name)) {\n    return !![name, "true"].includes(attr);\n  }\n\n  if (attr === "") return true;\n  return attr;\n} // packages/alpinejs/src/utils/debounce.js\n\n\nfunction debounce(func, wait) {\n  var timeout;\n  return function () {\n    var context = this,\n        args = arguments;\n\n    var later = function later() {\n      timeout = null;\n      func.apply(context, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n} // packages/alpinejs/src/utils/throttle.js\n\n\nfunction throttle(func, limit) {\n  var inThrottle;\n  return function () {\n    var context = this,\n        args = arguments;\n\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n} // packages/alpinejs/src/plugin.js\n\n\nfunction plugin(callback) {\n  callback(alpine_default);\n} // packages/alpinejs/src/store.js\n\n\nvar stores = {};\nvar isReactive = false;\n\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n\n  if (value === void 0) {\n    return stores[name];\n  }\n\n  stores[name] = value;\n\n  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {\n    stores[name].init();\n  }\n\n  initInterceptors(stores[name]);\n}\n\nfunction getStores() {\n  return stores;\n} // packages/alpinejs/src/binds.js\n\n\nvar binds = {};\n\nfunction bind2(name, object) {\n  binds[name] = typeof object !== "function" ? () => object : object;\n}\n\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(_ref16 => {\n    var [name, callback] = _ref16;\n    Object.defineProperty(obj, name, {\n      get() {\n        return function () {\n          return callback(...arguments);\n        };\n      }\n\n    });\n  });\n  return obj;\n} // packages/alpinejs/src/datas.js\n\n\nvar datas = {};\n\nfunction data(name, callback) {\n  datas[name] = callback;\n}\n\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(_ref17 => {\n    var [name, callback] = _ref17;\n    Object.defineProperty(obj, name, {\n      get() {\n        return function () {\n          return callback.bind(context)(...arguments);\n        };\n      },\n\n      enumerable: false\n    });\n  });\n  return obj;\n} // packages/alpinejs/src/alpine.js\n\n\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n\n  get release() {\n    return release;\n  },\n\n  get effect() {\n    return effect;\n  },\n\n  get raw() {\n    return raw;\n  },\n\n  version: "3.10.0",\n  flushAndStopDeferringMutations,\n  dontAutoEvaluateFunctions,\n  disableEffectScheduling,\n  setReactivityEngine,\n  closestDataStack,\n  skipDuringClone,\n  addRootSelector,\n  addInitSelector,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  setEvaluator,\n  mergeProxies,\n  findClosest,\n  closestRoot,\n  interceptor,\n  transition,\n  setStyles,\n  mutateDom,\n  directive,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  bound: getBinding,\n  $data: scope,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine; // node_modules/@vue/shared/dist/shared.esm-bundler.js\n\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(",");\n\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\nvar PatchFlagNames = {\n  [1]: "TEXT",\n  [2]: "CLASS",\n  [4]: "STYLE",\n  [8]: "PROPS",\n  [16]: "FULL_PROPS",\n  [32]: "HYDRATE_EVENTS",\n  [64]: "STABLE_FRAGMENT",\n  [128]: "KEYED_FRAGMENT",\n  [256]: "UNKEYED_FRAGMENT",\n  [512]: "NEED_PATCH",\n  [1024]: "DYNAMIC_SLOTS",\n  [2048]: "DEV_ROOT_FRAGMENT",\n  [-1]: "HOISTED",\n  [-2]: "BAIL"\n};\nvar slotFlagsText = {\n  [1]: "STABLE",\n  [2]: "DYNAMIC",\n  [3]: "FORWARDED"\n};\nvar specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";\nvar isBooleanAttr2 = /* @__PURE__ */makeMap(specialBooleanAttrs + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");\nvar EMPTY_OBJ =  false ? 0 : {};\nvar EMPTY_ARR =  false ? 0 : [];\nvar extend = Object.assign;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar hasOwn = (val, key) => hasOwnProperty.call(val, key);\n\nvar isArray = Array.isArray;\n\nvar isMap = val => toTypeString(val) === "[object Map]";\n\nvar isString = val => typeof val === "string";\n\nvar isSymbol = val => typeof val === "symbol";\n\nvar isObject = val => val !== null && typeof val === "object";\n\nvar objectToString = Object.prototype.toString;\n\nvar toTypeString = value => objectToString.call(value);\n\nvar toRawType = value => {\n  return toTypeString(value).slice(8, -1);\n};\n\nvar isIntegerKey = key => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;\n\nvar cacheStringFunction = fn => {\n  var cache = Object.create(null);\n  return str => {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");\n});\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, "-$1").toLowerCase());\nvar capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));\nvar toHandlerKey = cacheStringFunction(str => str ? "on".concat(capitalize(str)) : "");\n\nvar hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue); // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n\n\nvar targetMap = new WeakMap();\nvar effectStack = [];\nvar activeEffect;\nvar ITERATE_KEY = Symbol( false ? 0 : "");\nvar MAP_KEY_ITERATE_KEY = Symbol( false ? 0 : "");\n\nfunction isEffect(fn) {\n  return fn && fn._isEffect === true;\n}\n\nfunction effect2(fn) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_OBJ;\n\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n\n  var effect3 = createReactiveEffect(fn, options);\n\n  if (!options.lazy) {\n    effect3();\n  }\n\n  return effect3;\n}\n\nfunction stop(effect3) {\n  if (effect3.active) {\n    cleanup(effect3);\n\n    if (effect3.options.onStop) {\n      effect3.options.onStop();\n    }\n\n    effect3.active = false;\n  }\n}\n\nvar uid = 0;\n\nfunction createReactiveEffect(fn, options) {\n  var effect3 = function reactiveEffect() {\n    if (!effect3.active) {\n      return fn();\n    }\n\n    if (!effectStack.includes(effect3)) {\n      cleanup(effect3);\n\n      try {\n        enableTracking();\n        effectStack.push(effect3);\n        activeEffect = effect3;\n        return fn();\n      } finally {\n        effectStack.pop();\n        resetTracking();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n\n  effect3.id = uid++;\n  effect3.allowRecurse = !!options.allowRecurse;\n  effect3._isEffect = true;\n  effect3.active = true;\n  effect3.raw = fn;\n  effect3.deps = [];\n  effect3.options = options;\n  return effect3;\n}\n\nfunction cleanup(effect3) {\n  var {\n    deps\n  } = effect3;\n\n  if (deps.length) {\n    for (var i = 0; i < deps.length; i++) {\n      deps[i].delete(effect3);\n    }\n\n    deps.length = 0;\n  }\n}\n\nvar shouldTrack = true;\nvar trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  var last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === void 0) {\n    return;\n  }\n\n  var depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    targetMap.set(target, depsMap = new Map());\n  }\n\n  var dep = depsMap.get(key);\n\n  if (!dep) {\n    depsMap.set(key, dep = new Set());\n  }\n\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (false) {}\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  var depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    return;\n  }\n\n  var effects = new Set();\n\n  var add2 = effectsToAdd => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect3 => {\n        if (effect3 !== activeEffect || effect3.allowRecurse) {\n          effects.add(effect3);\n        }\n      });\n    }\n  };\n\n  if (type === "clear") {\n    depsMap.forEach(add2);\n  } else if (key === "length" && isArray(target)) {\n    depsMap.forEach((dep, key2) => {\n      if (key2 === "length" || key2 >= newValue) {\n        add2(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      add2(depsMap.get(key));\n    }\n\n    switch (type) {\n      case "add":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          add2(depsMap.get("length"));\n        }\n\n        break;\n\n      case "delete":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case "set":\n        if (isMap(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  var run = effect3 => {\n    if (false) {}\n\n    if (effect3.options.scheduler) {\n      effect3.options.scheduler(effect3);\n    } else {\n      effect3();\n    }\n  };\n\n  effects.forEach(run);\n}\n\nvar isNonTrackableKeys = /* @__PURE__ */makeMap("__proto__,__v_isRef,__isVue");\nvar builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(isSymbol));\nvar get2 = /* @__PURE__ */createGetter();\nvar shallowGet = /* @__PURE__ */createGetter(false, true);\nvar readonlyGet = /* @__PURE__ */createGetter(true);\nvar shallowReadonlyGet = /* @__PURE__ */createGetter(true, true);\nvar arrayInstrumentations = {};\n["includes", "indexOf", "lastIndexOf"].forEach(key => {\n  var method = Array.prototype[key];\n\n  arrayInstrumentations[key] = function () {\n    var arr = toRaw(this);\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      track(arr, "get", i + "");\n    }\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var res = method.apply(arr, args);\n\n    if (res === -1 || res === false) {\n      return method.apply(arr, args.map(toRaw));\n    } else {\n      return res;\n    }\n  };\n});\n["push", "pop", "shift", "unshift", "splice"].forEach(key => {\n  var method = Array.prototype[key];\n\n  arrayInstrumentations[key] = function () {\n    pauseTracking();\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var res = method.apply(this, args);\n    resetTracking();\n    return res;\n  };\n});\n\nfunction createGetter() {\n  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function get3(target, key, receiver) {\n    if (key === "__v_isReactive") {\n      return !isReadonly;\n    } else if (key === "__v_isReadonly") {\n      return isReadonly;\n    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    var targetIsArray = isArray(target);\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n\n    var res = Reflect.get(target, key, receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly) {\n      track(target, "get", key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      var shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive2(res);\n    }\n\n    return res;\n  };\n}\n\nvar set2 = /* @__PURE__ */createSetter();\nvar shallowSet = /* @__PURE__ */createSetter(true);\n\nfunction createSetter() {\n  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function set3(target, key, value, receiver) {\n    var oldValue = target[key];\n\n    if (!shallow) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    var result = Reflect.set(target, key, value, receiver);\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, "add", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, "set", key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  var hadKey = hasOwn(target, key);\n  var oldValue = target[key];\n  var result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, "delete", key, void 0, oldValue);\n  }\n\n  return result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key);\n\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, "has", key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nvar mutableHandlers = {\n  get: get2,\n  set: set2,\n  deleteProperty,\n  has,\n  ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n\n  set(target, key) {\n    if (false) {}\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    if (false) {}\n\n    return true;\n  }\n\n};\nvar shallowReactiveHandlers = extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\nvar shallowReadonlyHandlers = extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nvar toReactive = value => isObject(value) ? reactive2(value) : value;\n\nvar toReadonly = value => isObject(value) ? readonly(value) : value;\n\nvar toShallow = value => value;\n\nvar getProto = v => Reflect.getPrototypeOf(v);\n\nfunction get$1(target, key) {\n  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  target = target["__v_raw"];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, "get", key);\n  }\n\n  !isReadonly && track(rawTarget, "get", rawKey);\n  var {\n    has: has2\n  } = getProto(rawTarget);\n  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\n\nfunction has$1(key) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var target = this["__v_raw"];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, "has", key);\n  }\n\n  !isReadonly && track(rawTarget, "has", rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  target = target["__v_raw"];\n  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);\n  return Reflect.get(target, "size", target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n  var proto = getProto(target);\n  var hadKey = proto.has.call(target, value);\n\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, "add", value, value);\n  }\n\n  return this;\n}\n\nfunction set$1(key, value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n  var {\n    has: has2,\n    get: get3\n  } = getProto(target);\n  var hadKey = has2.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (false) {}\n\n  var oldValue = get3.call(target, key);\n  target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, "add", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, "set", key, value, oldValue);\n  }\n\n  return this;\n}\n\nfunction deleteEntry(key) {\n  var target = toRaw(this);\n  var {\n    has: has2,\n    get: get3\n  } = getProto(target);\n  var hadKey = has2.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (false) {}\n\n  var oldValue = get3 ? get3.call(target, key) : void 0;\n  var result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, "delete", key, void 0, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  var target = toRaw(this);\n  var hadItems = target.size !== 0;\n  var oldTarget =  false ? 0 : void 0;\n  var result = target.clear();\n\n  if (hadItems) {\n    trigger(target, "clear", void 0, void 0, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    var observed = this;\n    var target = observed["__v_raw"];\n    var rawTarget = toRaw(target);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function () {\n    var target = this["__v_raw"];\n    var rawTarget = toRaw(target);\n    var targetIsMap = isMap(rawTarget);\n    var isPair = method === "entries" || method === Symbol.iterator && targetIsMap;\n    var isKeyOnly = method === "keys" && targetIsMap;\n    var innerIterator = target[method](...arguments);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      next() {\n        var {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function () {\n    if (false) { var key; }\n\n    return type === "delete" ? false : this;\n  };\n}\n\nvar mutableInstrumentations = {\n  get(key) {\n    return get$1(this, key);\n  },\n\n  get size() {\n    return size(this);\n  },\n\n  has: has$1,\n  add,\n  set: set$1,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false, false)\n};\nvar shallowInstrumentations = {\n  get(key) {\n    return get$1(this, key, false, true);\n  },\n\n  get size() {\n    return size(this);\n  },\n\n  has: has$1,\n  add,\n  set: set$1,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false, true)\n};\nvar readonlyInstrumentations = {\n  get(key) {\n    return get$1(this, key, true);\n  },\n\n  get size() {\n    return size(this, true);\n  },\n\n  has(key) {\n    return has$1.call(this, key, true);\n  },\n\n  add: createReadonlyMethod("add"),\n  set: createReadonlyMethod("set"),\n  delete: createReadonlyMethod("delete"),\n  clear: createReadonlyMethod("clear"),\n  forEach: createForEach(true, false)\n};\nvar shallowReadonlyInstrumentations = {\n  get(key) {\n    return get$1(this, key, true, true);\n  },\n\n  get size() {\n    return size(this, true);\n  },\n\n  has(key) {\n    return has$1.call(this, key, true);\n  },\n\n  add: createReadonlyMethod("add"),\n  set: createReadonlyMethod("set"),\n  delete: createReadonlyMethod("delete"),\n  clear: createReadonlyMethod("clear"),\n  forEach: createForEach(true, true)\n};\nvar iteratorMethods = ["keys", "values", "entries", Symbol.iterator];\niteratorMethods.forEach(method => {\n  mutableInstrumentations[method] = createIterableMethod(method, false, false);\n  readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n  shallowInstrumentations[method] = createIterableMethod(method, false, true);\n  shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n});\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === "__v_isReactive") {\n      return !isReadonly;\n    } else if (key === "__v_isReadonly") {\n      return isReadonly;\n    } else if (key === "__v_raw") {\n      return target;\n    }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nvar mutableCollectionHandlers = {\n  get: createInstrumentationGetter(false, false)\n};\nvar shallowCollectionHandlers = {\n  get: createInstrumentationGetter(false, true)\n};\nvar readonlyCollectionHandlers = {\n  get: createInstrumentationGetter(true, false)\n};\nvar shallowReadonlyCollectionHandlers = {\n  get: createInstrumentationGetter(true, true)\n};\nvar reactiveMap = new WeakMap();\nvar shallowReactiveMap = new WeakMap();\nvar readonlyMap = new WeakMap();\nvar shallowReadonlyMap = new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case "Object":\n    case "Array":\n      return 1;\n\n    case "Map":\n    case "Set":\n    case "WeakMap":\n    case "WeakSet":\n      return 2;\n\n    default:\n      return 0;\n  }\n}\n\nfunction getTargetType(value) {\n  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\n}\n\nfunction reactive2(target) {\n  if (target && target["__v_isReadonly"]) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (false) {}\n\n    return target;\n  }\n\n  if (target["__v_raw"] && !(isReadonly && target["__v_isReactive"])) {\n    return target;\n  }\n\n  var existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  }\n\n  var targetType = getTargetType(target);\n\n  if (targetType === 0) {\n    return target;\n  }\n\n  var proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction toRaw(observed) {\n  return observed && toRaw(observed["__v_raw"]) || observed;\n}\n\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n} // packages/alpinejs/src/magics/$nextTick.js\n\n\nmagic("nextTick", () => nextTick); // packages/alpinejs/src/magics/$dispatch.js\n\nmagic("dispatch", el => dispatch.bind(dispatch, el)); // packages/alpinejs/src/magics/$watch.js\n\nmagic("watch", (el, _ref18) => {\n  var {\n    evaluateLater: evaluateLater2,\n    effect: effect3\n  } = _ref18;\n  return (key, callback) => {\n    var evaluate2 = evaluateLater2(key);\n    var firstTime = true;\n    var oldValue;\n    var effectReference = effect3(() => evaluate2(value => {\n      JSON.stringify(value);\n\n      if (!firstTime) {\n        queueMicrotask(() => {\n          callback(value, oldValue);\n          oldValue = value;\n        });\n      } else {\n        oldValue = value;\n      }\n\n      firstTime = false;\n    }));\n\n    el._x_effects.delete(effectReference);\n  };\n}); // packages/alpinejs/src/magics/$store.js\n\nmagic("store", getStores); // packages/alpinejs/src/magics/$data.js\n\nmagic("data", el => scope(el)); // packages/alpinejs/src/magics/$root.js\n\nmagic("root", el => closestRoot(el)); // packages/alpinejs/src/magics/$refs.js\n\nmagic("refs", el => {\n  if (el._x_refs_proxy) return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\n\nfunction getArrayOfRefObject(el) {\n  var refObjects = [];\n  var currentEl = el;\n\n  while (currentEl) {\n    if (currentEl._x_refs) refObjects.push(currentEl._x_refs);\n    currentEl = currentEl.parentNode;\n  }\n\n  return refObjects;\n} // packages/alpinejs/src/ids.js\n\n\nvar globalIdMemo = {};\n\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name]) globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\n\nfunction closestIdRoot(el, name) {\n  return findClosest(el, element => {\n    if (element._x_ids && element._x_ids[name]) return true;\n  });\n}\n\nfunction setIdRoot(el, name) {\n  if (!el._x_ids) el._x_ids = {};\n  if (!el._x_ids[name]) el._x_ids[name] = findAndIncrementId(name);\n} // packages/alpinejs/src/magics/$id.js\n\n\nmagic("id", el => function (name) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var root = closestIdRoot(el, name);\n  var id = root ? root._x_ids[name] : findAndIncrementId(name);\n  return key ? "".concat(name, "-").concat(id, "-").concat(key) : "".concat(name, "-").concat(id);\n}); // packages/alpinejs/src/magics/$el.js\n\nmagic("el", el => el); // packages/alpinejs/src/magics/index.js\n\nwarnMissingPluginMagic("Focus", "focus", "focus");\nwarnMissingPluginMagic("Persist", "persist", "persist");\n\nfunction warnMissingPluginMagic(name, magicName, slug) {\n  magic(magicName, el => warn("You can\'t use [$".concat(directiveName, "] without first installing the \\"").concat(name, "\\" plugin here: https://alpinejs.dev/plugins/").concat(slug), el));\n} // packages/alpinejs/src/directives/x-modelable.js\n\n\ndirective("modelable", (el, _ref19, _ref20) => {\n  var {\n    expression\n  } = _ref19;\n  var {\n    effect: effect3,\n    evaluateLater: evaluateLater2\n  } = _ref20;\n  var func = evaluateLater2(expression);\n\n  var innerGet = () => {\n    var result;\n    func(i => result = i);\n    return result;\n  };\n\n  var evaluateInnerSet = evaluateLater2("".concat(expression, " = __placeholder"));\n\n  var innerSet = val => evaluateInnerSet(() => {}, {\n    scope: {\n      __placeholder: val\n    }\n  });\n\n  var initialValue = innerGet();\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model) return;\n\n    el._x_removeModelListeners["default"]();\n\n    var outerGet = el._x_model.get;\n    var outerSet = el._x_model.set;\n    effect3(() => innerSet(outerGet()));\n    effect3(() => outerSet(innerGet()));\n  });\n}); // packages/alpinejs/src/directives/x-teleport.js\n\ndirective("teleport", (el, _ref21, _ref22) => {\n  var {\n    expression\n  } = _ref21;\n  var {\n    cleanup: cleanup2\n  } = _ref22;\n  if (el.tagName.toLowerCase() !== "template") warn("x-teleport can only be used on a <template> tag", el);\n  var target = document.querySelector(expression);\n  if (!target) warn("Cannot find x-teleport element for selector: \\"".concat(expression, "\\""));\n  var clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach(eventName => {\n      clone2.addEventListener(eventName, e => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n\n  addScopeToNode(clone2, {}, el);\n  mutateDom(() => {\n    target.appendChild(clone2);\n    initTree(clone2);\n    clone2._x_ignore = true;\n  });\n  cleanup2(() => clone2.remove());\n}); // packages/alpinejs/src/directives/x-ignore.js\n\nvar handler = () => {};\n\nhandler.inline = (el, _ref23, _ref24) => {\n  var {\n    modifiers\n  } = _ref23;\n  var {\n    cleanup: cleanup2\n  } = _ref24;\n  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup2(() => {\n    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\n\ndirective("ignore", handler); // packages/alpinejs/src/directives/x-effect.js\n\ndirective("effect", (el, _ref25, _ref26) => {\n  var {\n    expression\n  } = _ref25;\n  var {\n    effect: effect3\n  } = _ref26;\n  return effect3(evaluateLater(el, expression));\n}); // packages/alpinejs/src/utils/on.js\n\nfunction on(el, event, modifiers, callback) {\n  var listenerTarget = el;\n\n  var handler3 = e => callback(e);\n\n  var options = {};\n\n  var wrapHandler = (callback2, wrapper) => e => wrapper(callback2, e);\n\n  if (modifiers.includes("dot")) event = dotSyntax(event);\n  if (modifiers.includes("camel")) event = camelCase2(event);\n  if (modifiers.includes("passive")) options.passive = true;\n  if (modifiers.includes("capture")) options.capture = true;\n  if (modifiers.includes("window")) listenerTarget = window;\n  if (modifiers.includes("document")) listenerTarget = document;\n  if (modifiers.includes("prevent")) handler3 = wrapHandler(handler3, (next, e) => {\n    e.preventDefault();\n    next(e);\n  });\n  if (modifiers.includes("stop")) handler3 = wrapHandler(handler3, (next, e) => {\n    e.stopPropagation();\n    next(e);\n  });\n  if (modifiers.includes("self")) handler3 = wrapHandler(handler3, (next, e) => {\n    e.target === el && next(e);\n  });\n\n  if (modifiers.includes("away") || modifiers.includes("outside")) {\n    listenerTarget = document;\n    handler3 = wrapHandler(handler3, (next, e) => {\n      if (el.contains(e.target)) return;\n      if (e.target.isConnected === false) return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1) return;\n      if (el._x_isShown === false) return;\n      next(e);\n    });\n  }\n\n  if (modifiers.includes("once")) {\n    handler3 = wrapHandler(handler3, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler3, options);\n    });\n  }\n\n  handler3 = wrapHandler(handler3, (next, e) => {\n    if (isKeyEvent(event)) {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n    }\n\n    next(e);\n  });\n\n  if (modifiers.includes("debounce")) {\n    var nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";\n    var wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;\n    handler3 = debounce(handler3, wait);\n  }\n\n  if (modifiers.includes("throttle")) {\n    var _nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";\n\n    var _wait = isNumeric(_nextModifier.split("ms")[0]) ? Number(_nextModifier.split("ms")[0]) : 250;\n\n    handler3 = throttle(handler3, _wait);\n  }\n\n  listenerTarget.addEventListener(event, handler3, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler3, options);\n  };\n}\n\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, ".");\n}\n\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\n\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\nfunction kebabCase2(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\\s]/, "-").toLowerCase();\n}\n\nfunction isKeyEvent(event) {\n  return ["keydown", "keyup"].includes(event);\n}\n\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  var keyModifiers = modifiers.filter(i => {\n    return !["window", "document", "prevent", "stop", "once"].includes(i);\n  });\n\n  if (keyModifiers.includes("debounce")) {\n    var debounceIndex = keyModifiers.indexOf("debounce");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);\n  }\n\n  if (keyModifiers.length === 0) return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0])) return false;\n  var systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];\n  var selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));\n\n  if (selectedSystemKeyModifiers.length > 0) {\n    var activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n      if (modifier === "cmd" || modifier === "super") modifier = "meta";\n      return e["".concat(modifier, "Key")];\n    });\n\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (keyToModifiers(e.key).includes(keyModifiers[0])) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction keyToModifiers(key) {\n  if (!key) return [];\n  key = kebabCase2(key);\n  var modifierToKeyMap = {\n    ctrl: "control",\n    slash: "/",\n    space: "-",\n    spacebar: "-",\n    cmd: "meta",\n    esc: "escape",\n    up: "arrow-up",\n    down: "arrow-down",\n    left: "arrow-left",\n    right: "arrow-right",\n    period: ".",\n    equal: "="\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map(modifier => {\n    if (modifierToKeyMap[modifier] === key) return modifier;\n  }).filter(modifier => modifier);\n} // packages/alpinejs/src/directives/x-model.js\n\n\ndirective("model", (el, _ref27, _ref28) => {\n  var {\n    modifiers,\n    expression\n  } = _ref27;\n  var {\n    effect: effect3,\n    cleanup: cleanup2\n  } = _ref28;\n  var evaluate2 = evaluateLater(el, expression);\n  var assignmentExpression = "".concat(expression, " = rightSideOfExpression($event, ").concat(expression, ")");\n  var evaluateAssignment = evaluateLater(el, assignmentExpression);\n  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";\n  var assigmentFunction = generateAssignmentFunction(el, modifiers, expression);\n  var removeListener = on(el, event, modifiers, e => {\n    evaluateAssignment(() => {}, {\n      scope: {\n        $event: e,\n        rightSideOfExpression: assigmentFunction\n      }\n    });\n  });\n  if (!el._x_removeModelListeners) el._x_removeModelListeners = {};\n  el._x_removeModelListeners["default"] = removeListener;\n  cleanup2(() => el._x_removeModelListeners["default"]());\n  var evaluateSetModel = evaluateLater(el, "".concat(expression, " = __placeholder"));\n  el._x_model = {\n    get() {\n      var result;\n      evaluate2(value => result = value);\n      return result;\n    },\n\n    set(value) {\n      evaluateSetModel(() => {}, {\n        scope: {\n          __placeholder: value\n        }\n      });\n    }\n\n  };\n\n  el._x_forceModelUpdate = () => {\n    evaluate2(value => {\n      if (value === void 0 && expression.match(/\\./)) value = "";\n      window.fromModel = true;\n      mutateDom(() => bind(el, "value", value));\n      delete window.fromModel;\n    });\n  };\n\n  effect3(() => {\n    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el)) return;\n\n    el._x_forceModelUpdate();\n  });\n});\n\nfunction generateAssignmentFunction(el, modifiers, expression) {\n  if (el.type === "radio") {\n    mutateDom(() => {\n      if (!el.hasAttribute("name")) el.setAttribute("name", expression);\n    });\n  }\n\n  return (event, currentValue) => {\n    return mutateDom(() => {\n      if (event instanceof CustomEvent && event.detail !== void 0) {\n        return event.detail || event.target.value;\n      } else if (el.type === "checkbox") {\n        if (Array.isArray(currentValue)) {\n          var newValue = modifiers.includes("number") ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el2 => !checkedAttrLooseCompare2(el2, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {\n        return modifiers.includes("number") ? Array.from(event.target.selectedOptions).map(option => {\n          var rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map(option => {\n          return option.value || option.text;\n        });\n      } else {\n        var rawValue = event.target.value;\n        return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;\n      }\n    });\n  };\n}\n\nfunction safeParseNumber(rawValue) {\n  var number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\n\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\n\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n} // packages/alpinejs/src/directives/x-cloak.js\n\n\ndirective("cloak", el => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak"))))); // packages/alpinejs/src/directives/x-init.js\n\naddInitSelector(() => "[".concat(prefix("init"), "]"));\ndirective("init", skipDuringClone((el, _ref29, _ref30) => {\n  var {\n    expression\n  } = _ref29;\n  var {\n    evaluate: evaluate2\n  } = _ref30;\n\n  if (typeof expression === "string") {\n    return !!expression.trim() && evaluate2(expression, {}, false);\n  }\n\n  return evaluate2(expression, {}, false);\n})); // packages/alpinejs/src/directives/x-text.js\n\ndirective("text", (el, _ref31, _ref32) => {\n  var {\n    expression\n  } = _ref31;\n  var {\n    effect: effect3,\n    evaluateLater: evaluateLater2\n  } = _ref32;\n  var evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2(value => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n}); // packages/alpinejs/src/directives/x-html.js\n\ndirective("html", (el, _ref33, _ref34) => {\n  var {\n    expression\n  } = _ref33;\n  var {\n    effect: effect3,\n    evaluateLater: evaluateLater2\n  } = _ref34;\n  var evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2(value => {\n      mutateDom(() => {\n        el.innerHTML = value;\n        el._x_ignoreSelf = true;\n        initTree(el);\n        delete el._x_ignoreSelf;\n      });\n    });\n  });\n}); // packages/alpinejs/src/directives/x-bind.js\n\nmapAttributes(startingWith(":", into(prefix("bind:"))));\ndirective("bind", (el, _ref35, _ref36) => {\n  var {\n    value,\n    modifiers,\n    expression,\n    original\n  } = _ref35;\n  var {\n    effect: effect3\n  } = _ref36;\n\n  if (!value) {\n    return applyBindingsObject(el, expression, original, effect3);\n  }\n\n  if (value === "key") return storeKeyForXFor(el, expression);\n  var evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2(result => {\n    if (result === void 0 && expression.match(/\\./)) result = "";\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n});\n\nfunction applyBindingsObject(el, expression, original, effect3) {\n  var bindingProviders = {};\n  injectBindingProviders(bindingProviders);\n  var getBindings = evaluateLater(el, expression);\n  var cleanupRunners = [];\n\n  while (cleanupRunners.length) {\n    cleanupRunners.pop()();\n  }\n\n  getBindings(bindings => {\n    var attributes = Object.entries(bindings).map(_ref37 => {\n      var [name, value] = _ref37;\n      return {\n        name,\n        value\n      };\n    });\n    var staticAttributes = attributesOnly(attributes);\n    attributes = attributes.map(attribute => {\n      if (staticAttributes.find(attr => attr.name === attribute.name)) {\n        return {\n          name: "x-bind:".concat(attribute.name),\n          value: "\\"".concat(attribute.value, "\\"")\n        };\n      }\n\n      return attribute;\n    });\n    directives(el, attributes, original).map(handle => {\n      cleanupRunners.push(handle.runCleanups);\n      handle();\n    });\n  }, {\n    scope: bindingProviders\n  });\n}\n\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n} // packages/alpinejs/src/directives/x-data.js\n\n\naddRootSelector(() => "[".concat(prefix("data"), "]"));\ndirective("data", skipDuringClone((el, _ref38, _ref39) => {\n  var {\n    expression\n  } = _ref38;\n  var {\n    cleanup: cleanup2\n  } = _ref39;\n  expression = expression === "" ? "{}" : expression;\n  var magicContext = {};\n  injectMagics(magicContext, el);\n  var dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  var data2 = evaluate(el, expression, {\n    scope: dataProviderContext\n  });\n  if (data2 === void 0) data2 = {};\n  injectMagics(data2, el);\n  var reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  var undo = addScopeToNode(el, reactiveData);\n  reactiveData["init"] && evaluate(el, reactiveData["init"]);\n  cleanup2(() => {\n    reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);\n    undo();\n  });\n})); // packages/alpinejs/src/directives/x-show.js\n\ndirective("show", (el, _ref40, _ref41) => {\n  var {\n    modifiers,\n    expression\n  } = _ref40;\n  var {\n    effect: effect3\n  } = _ref41;\n  var evaluate2 = evaluateLater(el, expression);\n  if (!el._x_doHide) el._x_doHide = () => {\n    mutateDom(() => el.style.display = "none");\n  };\n  if (!el._x_doShow) el._x_doShow = () => {\n    mutateDom(() => {\n      if (el.style.length === 1 && el.style.display === "none") {\n        el.removeAttribute("style");\n      } else {\n        el.style.removeProperty("display");\n      }\n    });\n  };\n\n  var hide = () => {\n    el._x_doHide();\n\n    el._x_isShown = false;\n  };\n\n  var show = () => {\n    el._x_doShow();\n\n    el._x_isShown = true;\n  };\n\n  var clickAwayCompatibleShow = () => setTimeout(show);\n\n  var toggle = once(value => value ? show() : hide(), value => {\n    if (typeof el._x_toggleAndCascadeWithTransitions === "function") {\n      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n    } else {\n      value ? clickAwayCompatibleShow() : hide();\n    }\n  });\n  var oldValue;\n  var firstTime = true;\n  effect3(() => evaluate2(value => {\n    if (!firstTime && value === oldValue) return;\n    if (modifiers.includes("immediate")) value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n}); // packages/alpinejs/src/directives/x-for.js\n\ndirective("for", (el, _ref42, _ref43) => {\n  var {\n    expression\n  } = _ref42;\n  var {\n    effect: effect3,\n    cleanup: cleanup2\n  } = _ref43;\n  var iteratorNames = parseForExpression(expression);\n  var evaluateItems = evaluateLater(el, iteratorNames.items);\n  var evaluateKey = evaluateLater(el, el._x_keyExpression || "index");\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup2(() => {\n    Object.values(el._x_lookup).forEach(el2 => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\n\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  var isObject2 = i => typeof i === "object" && !Array.isArray(i);\n\n  var templateEl = el;\n  evaluateItems(items => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), i => i + 1);\n    }\n\n    if (items === void 0) items = [];\n    var lookup = el._x_lookup;\n    var prevKeys = el._x_prevKeys;\n    var scopes = [];\n    var keys = [];\n\n    if (isObject2(items)) {\n      items = Object.entries(items).map(_ref44 => {\n        var [key, value] = _ref44;\n        var scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey(value2 => keys.push(value2), {\n          scope: _objectSpread({\n            index: key\n          }, scope2)\n        });\n        scopes.push(scope2);\n      });\n    } else {\n      for (var i = 0; i < items.length; i++) {\n        var scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey(value => keys.push(value), {\n          scope: _objectSpread({\n            index: i\n          }, scope2)\n        });\n        scopes.push(scope2);\n      }\n    }\n\n    var adds = [];\n    var moves = [];\n    var removes = [];\n    var sames = [];\n\n    for (var _i = 0; _i < prevKeys.length; _i++) {\n      var key = prevKeys[_i];\n      if (keys.indexOf(key) === -1) removes.push(key);\n    }\n\n    prevKeys = prevKeys.filter(key => !removes.includes(key));\n    var lastKey = "template";\n\n    for (var _i2 = 0; _i2 < keys.length; _i2++) {\n      var _key5 = keys[_i2];\n      var prevIndex = prevKeys.indexOf(_key5);\n\n      if (prevIndex === -1) {\n        prevKeys.splice(_i2, 0, _key5);\n        adds.push([lastKey, _i2]);\n      } else if (prevIndex !== _i2) {\n        var keyInSpot = prevKeys.splice(_i2, 1)[0];\n        var keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(_i2, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(_key5);\n      }\n\n      lastKey = _key5;\n    }\n\n    for (var _i3 = 0; _i3 < removes.length; _i3++) {\n      var _key6 = removes[_i3];\n\n      if (!!lookup[_key6]._x_effects) {\n        lookup[_key6]._x_effects.forEach(dequeueJob);\n      }\n\n      lookup[_key6].remove();\n\n      lookup[_key6] = null;\n      delete lookup[_key6];\n    }\n\n    var _loop3 = function _loop3(_i4) {\n      var [keyInSpot, keyForSpot] = moves[_i4];\n      var elInSpot = lookup[keyInSpot];\n      var elForSpot = lookup[keyForSpot];\n      var marker = document.createElement("div");\n      mutateDom(() => {\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);\n    };\n\n    for (var _i4 = 0; _i4 < moves.length; _i4++) {\n      _loop3(_i4);\n    }\n\n    var _loop4 = function _loop4(_i5) {\n      var [lastKey2, index] = adds[_i5];\n      var lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl) lastEl = lastEl._x_currentIfEl;\n      var scope2 = scopes[index];\n      var key = keys[index];\n      var clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      addScopeToNode(clone2, reactive(scope2), templateEl);\n      mutateDom(() => {\n        lastEl.after(clone2);\n        initTree(clone2);\n      });\n\n      if (typeof key === "object") {\n        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);\n      }\n\n      lookup[key] = clone2;\n    };\n\n    for (var _i5 = 0; _i5 < adds.length; _i5++) {\n      _loop4(_i5);\n    }\n\n    for (var _i6 = 0; _i6 < sames.length; _i6++) {\n      refreshScope(lookup[sames[_i6]], scopes[keys.indexOf(sames[_i6])]);\n    }\n\n    templateEl._x_prevKeys = keys;\n  });\n}\n\nfunction parseForExpression(expression) {\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var inMatch = expression.match(forAliasRE);\n  if (!inMatch) return;\n  var res = {};\n  res.items = inMatch[2].trim();\n  var item = inMatch[1].replace(stripParensRE, "").trim();\n  var iteratorMatch = item.match(forIteratorRE);\n\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, "").trim();\n    res.index = iteratorMatch[1].trim();\n\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n\n  return res;\n}\n\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  var scopeVariables = {};\n\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    var names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map(i => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {\n    var _names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map(i => i.trim());\n\n    _names.forEach(name => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n\n  if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\n\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n} // packages/alpinejs/src/directives/x-ref.js\n\n\nfunction handler2() {}\n\nhandler2.inline = (el, _ref45, _ref46) => {\n  var {\n    expression\n  } = _ref45;\n  var {\n    cleanup: cleanup2\n  } = _ref46;\n  var root = closestRoot(el);\n  if (!root._x_refs) root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup2(() => delete root._x_refs[expression]);\n};\n\ndirective("ref", handler2); // packages/alpinejs/src/directives/x-if.js\n\ndirective("if", (el, _ref47, _ref48) => {\n  var {\n    expression\n  } = _ref47;\n  var {\n    effect: effect3,\n    cleanup: cleanup2\n  } = _ref48;\n  var evaluate2 = evaluateLater(el, expression);\n\n  var show = () => {\n    if (el._x_currentIfEl) return el._x_currentIfEl;\n    var clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      initTree(clone2);\n    });\n    el._x_currentIfEl = clone2;\n\n    el._x_undoIf = () => {\n      walk(clone2, node => {\n        if (!!node._x_effects) {\n          node._x_effects.forEach(dequeueJob);\n        }\n      });\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n\n    return clone2;\n  };\n\n  var hide = () => {\n    if (!el._x_undoIf) return;\n\n    el._x_undoIf();\n\n    delete el._x_undoIf;\n  };\n\n  effect3(() => evaluate2(value => {\n    value ? show() : hide();\n  }));\n  cleanup2(() => el._x_undoIf && el._x_undoIf());\n}); // packages/alpinejs/src/directives/x-id.js\n\ndirective("id", (el, _ref49, _ref50) => {\n  var {\n    expression\n  } = _ref49;\n  var {\n    evaluate: evaluate2\n  } = _ref50;\n  var names = evaluate2(expression);\n  names.forEach(name => setIdRoot(el, name));\n}); // packages/alpinejs/src/directives/x-on.js\n\nmapAttributes(startingWith("@", into(prefix("on:"))));\ndirective("on", skipDuringClone((el, _ref51, _ref52) => {\n  var {\n    value,\n    modifiers,\n    expression\n  } = _ref51;\n  var {\n    cleanup: cleanup2\n  } = _ref52;\n  var evaluate2 = expression ? evaluateLater(el, expression) : () => {};\n\n  if (el.tagName.toLowerCase() === "template") {\n    if (!el._x_forwardEvents) el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value)) el._x_forwardEvents.push(value);\n  }\n\n  var removeListener = on(el, value, modifiers, e => {\n    evaluate2(() => {}, {\n      scope: {\n        $event: e\n      },\n      params: [e]\n    });\n  });\n  cleanup2(() => removeListener());\n})); // packages/alpinejs/src/directives/index.js\n\nwarnMissingPluginDirective("Collapse", "collapse", "collapse");\nwarnMissingPluginDirective("Intersect", "intersect", "intersect");\nwarnMissingPluginDirective("Focus", "trap", "focus");\nwarnMissingPluginDirective("Mask", "mask", "mask");\n\nfunction warnMissingPluginDirective(name, directiveName2, slug) {\n  directive(directiveName2, el => warn("You can\'t use [x-".concat(directiveName2, "] without first installing the \\"").concat(name, "\\" plugin here: https://alpinejs.dev/plugins/").concat(slug), el));\n} // packages/alpinejs/src/index.js\n\n\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({\n  reactive: reactive2,\n  effect: effect2,\n  release: stop,\n  raw: toRaw\n});\nvar src_default = alpine_default; // packages/alpinejs/builds/module.js\n\nvar module_default = src_default;\n\n\n//# sourceURL=webpack://django-restapi-demo/./node_modules/alpinejs/dist/module.esm.js?')},"./node_modules/regenerator-runtime/runtime.js":function(module){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, "");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: "normal",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: "throw",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n\n\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, "constructor", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, "GeneratorFunction");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke("next", value, resolve, reject);\n          }, function (err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === "throw") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        // Note: ["return"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator["return"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError("The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, "toString", function () {\n    return "[object Generator]";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: "root"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = "next";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" || record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    "catch": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error("illegal catch attempt");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you\'ve misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you\'re not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === "object") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function("r", "regeneratorRuntime = r")(runtime);\n  }\n}\n\n//# sourceURL=webpack://django-restapi-demo/./node_modules/regenerator-runtime/runtime.js?')}},function(e){var n=function(n){return e(e.s=n)};n("./node_modules/regenerator-runtime/runtime.js"),n("./node_modules/alpinejs/dist/module.esm.js")}]);